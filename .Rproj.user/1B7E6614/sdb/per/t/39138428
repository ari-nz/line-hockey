{
    "collab_server" : "",
    "contents" : "CreateBoard<-function(size = 7, walls = T){\n  \n  if(length(size) == 1){\n    size = c(size, size)\n  }\n  \n  ## TODO - Assert the size is odd\n  \n  #Create game board Plot\n  plot(0,0, type = 'n', xlim = c(0.5,size[1]+0.5), ylim = c(-0.5, size[2]+2), xann = NULL, yann = NULL, axes = FALSE, xlab = \"\", ylab = \"\", asp = 1 )\n  \n  #Create set of plotable points\n  GamePoints = data.frame(\n              \"rows\" = rep(1:size[2], size[1]),\n              \"cols\" = rep(1:size[1], each = size[2]),\n              \"uID\"  = 1:(size[1]*size[2])\n  )\n \n  #Add points to graph\n  points(GamePoints$cols,GamePoints$rows, pch = 16)\n  text(GamePoints$cols+0.15,GamePoints$rows+0.1, labels = paste0(GamePoints$cols,\", \",GamePoints$rows), cex = 0.8)\n  text(GamePoints$cols-0.15,GamePoints$rows-0.1, labels = GamePoints$uID, col = 'red', cex = 0.8)\n  points(rep(ceiling(size[1]/2),2), c(0,size[2]+1), pch = 21, bg = c('blue','red'), cex = 1.5)\n  text(x=rep(ceiling(size[1]/2),2), y=c(-0.5,size[2]+1.5),labels =c(\"Player 1 Come Here\", \"Player 2 Come Here\"), col = c('blue','red'), cex = 1.5)\n  \n  \n  \n  #Create Game Board Matrix\n  GameBoard <- t(matrix(data = 0, nrow = size[1], ncol = size[2]))\n  \n  #Start the first node off as entered\n  middle_node = (size[1] *size[2] + 1)/2\n  GameBoard[middle_node]=GameBoard[middle_node]+1 \n\n  \n  ## Add these in if you need an extra line at the top and bottom of the bame board\n  #GameBoard <- matrix(data = 0, nrow = size[1]+2, ncol = size[2])\n  #GameBoard[c(1,size[1]+2),] = NA\n  #GameBoard[c(1,size[1]+2),ceiling(size[2]/2)] = 0\n  \n  \n  #Initialise matrix of possible moves\n  MoveMatrix = .InitialiseMoveMatrix(GamePoints)\n\n  \n  #Randomise Starting player\n  Turn = sample(c(1,2),1)\n  \n  \n  #Wrap the Initialisation up in the game state\n  GameState = list(\"GameBoard\" = GameBoard, \"GamePoints\" = GamePoints, \"MoveMatrix\" = MoveMatrix, \"Turn\" = Turn)\n  \n  \n  #Holds the number of moves through a points required to draw on that point, ie 2 in the corners causeon the second time into that point\n  GameState$MaxGameBoard = .InitialiseMaxGameBoard(GameState)\n  \n  ## TODO Build walls and add them to matrix\n  #if(walls){\n  #  GameState = BuildTheWall(GameState)\n  #}\n  \n  return(GameState)\n}\n\n\n.BuildTheWall <- function(size, walls){\n\n  \n}\n\n.InitialiseMaxGameBoard <- function(GameState){\n  size = dim(GameState$GameBoard)\n  middle_node = (size[1] *size[2] + 1)/2\n  n_nodes = size[1] * size[2]\n  \n  MaxGameBoard = GameState$GameBoard\n  \n  for (i in 1:n_nodes) {\n    \n    MaxGameBoard[1 + (i-1) %% size[1],(i-1) %/% size[1] + 1] = length(which(GameState$MoveMatrix[i,]>=0))\n  }\n  MaxGameBoard[middle_node]=MaxGameBoard[middle_node]+1 \n  MaxGameBoard[which(MaxGameBoard%%2 == 0)] = 0\n  MaxGameBoard = ceiling(MaxGameBoard/2)\n  \n  return(MaxGameBoard)\n}\n\n\n.InitialiseMoveMatrix<-function(GamePoints){\n  \n    # Create a matrix which stores which links between points have been done. \n    #   NA - Impossible move\n    #   0  - Available Move\n    #   1  - User made move\n    #   -1 - Going from to location\n    \n    n.uniquePoints = dim.data.frame(GamePoints)[1]\n    x.max = max(GamePoints$cols)\n    y.max = max(GamePoints$rows)\n    MoveMatrix =  matrix(data = NA, nrow = n.uniquePoints, ncol = n.uniquePoints)\n    \n    for (i in 1:n.uniquePoints){\n      checkPoint = GamePoints[i,]\n      x.loc = checkPoint$cols\n      y.loc = checkPoint$rows\n      #make sure that the available moves at a given point are within the bounds and are only for adjacent moves\n      for (j in (x.loc-1):(x.loc+1)){\n        # if the adjacent positions are not outside the bounds\n        if( j > 0 & j <= x.max){\n          \n          for (k in (y.loc-1):(y.loc+1)){\n            if( k > 0 & k <= y.max){\n              #browser()\n              node_searched = intersect(which(GamePoints$col == j), which(GamePoints$row == k))\n              #print(paste(\"Current Node = \", i, \"\\nj and k are, \",j,k, \"\\nFound node, \", node_searched))\n              MoveMatrix[i,node_searched] = 0\n              \n              \n            }\n          }\n        }\n      }\n    }\n    \n    diag(MoveMatrix) = -1\n    return(MoveMatrix)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1481845167575.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "820350465",
    "id" : "39138428",
    "lastKnownWriteTime" : 1481848226,
    "last_content_update" : 1481848226998,
    "path" : "C:/Users/Ari/Desktop/Line Hockey/Line Hockey/./Board/CreateGameBoard.R",
    "project_path" : "./Board/CreateGameBoard.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}